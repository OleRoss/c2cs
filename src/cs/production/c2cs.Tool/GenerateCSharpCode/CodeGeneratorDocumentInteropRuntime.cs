// Copyright (c) Bottlenose Labs Inc. (https://github.com/bottlenoselabs). All rights reserved.
// Licensed under the MIT license. See LICENSE file in the Git repository root directory for full license information.

using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace C2CS.GenerateCSharpCode;

public sealed class CodeGeneratorDocumentInteropRuntime
{
    public CodeProjectDocument Generate(CodeGeneratorDocumentOptions options)
    {
        var codeTemplate = $"""
                   // <auto-generated>
                   //  This code was generated by the following tool on {options.DateTimeStamp}:
                   //      https://github.com/bottlenoselabs/c2cs (v{options.VersionStamp})
                   //
                   //  Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
                   // </auto-generated>
                   // ReSharper disable All

                   // To disable generating this file set `isEnabledGeneratingRuntimeCode` to `false` in the config file for generating C# code.

                   using System;
                   using System.Globalization;
                   using System.Runtime.InteropServices;
                   using System.Threading;

                   namespace Interop.Runtime{(options.IsEnabledFileScopedNamespace ? ";" : "{}")}

                   """;

        var compilationUnitRoot = SyntaxFactory.ParseSyntaxTree(codeTemplate).GetCompilationUnitRoot();
        var rootNamespaceOriginal = (BaseNamespaceDeclarationSyntax)compilationUnitRoot.Members[0];
        var members = CreateMembers(options);
        var rootNamespaceWithMembers = rootNamespaceOriginal
            .WithMembers(rootNamespaceOriginal.Members.AddRange(members));
        var code = compilationUnitRoot
            .ReplaceNode(rootNamespaceOriginal, rootNamespaceWithMembers)
            .GetCode();

        var document = new CodeProjectDocument
        {
            FileName = "Runtime.g.cs",
            Code = code
        };

        return document;
    }

    private static ImmutableArray<MemberDeclarationSyntax> CreateMembers(CodeGeneratorDocumentOptions options)
    {
        var assembly = Assembly.GetExecutingAssembly();
        var resourcesNames = assembly.GetManifestResourceNames();
        var builderMembers = ImmutableArray.CreateBuilder<MemberDeclarationSyntax>();

        foreach (var resourceName in resourcesNames)
        {
            CreateMember(resourceName, assembly, builderMembers, options);
        }

        return builderMembers.ToImmutable();
    }

    private static void CreateMember(
        string resourceName,
        Assembly assembly,
        ImmutableArray<MemberDeclarationSyntax>.Builder builderMembers,
        CodeGeneratorDocumentOptions options)
    {
        if (!resourceName.EndsWith(".cs", StringComparison.InvariantCulture))
        {
            return;
        }

        using var stream = assembly.GetManifestResourceStream(resourceName);
        using var streamReader = new StreamReader(stream!);
        var fileContents = streamReader
            .ReadToEnd()
            .Replace($"{Environment.NewLine}namespace Interop.Runtime;{Environment.NewLine}", string.Empty, StringComparison.InvariantCulture);

        var syntaxTree = SyntaxFactory.ParseSyntaxTree(fileContents);
        if (syntaxTree.GetRoot() is not CompilationUnitSyntax compilationUnit)
        {
            return;
        }

        foreach (var member in compilationUnit.Members)
        {
            var modifiedMember = ModifyMemberAccessModifier(member, options.IsEnabledAccessModifierInternal);
            builderMembers.Add(modifiedMember);
        }
    }

    private static MemberDeclarationSyntax ModifyMemberAccessModifier(
        MemberDeclarationSyntax member,
        bool isEnabledAccessModifierInternal)
    {
        if (member is not TypeDeclarationSyntax typeDeclaration)
        {
            return member;
        }

        var newModifier = isEnabledAccessModifierInternal
            ? SyntaxFactory.Token(SyntaxKind.InternalKeyword)
            : SyntaxFactory.Token(SyntaxKind.PublicKeyword);

        var existingModifiers = typeDeclaration.Modifiers;
        var leadingTrivia = existingModifiers.Count > 0
            ? existingModifiers[0].LeadingTrivia
            : typeDeclaration.GetLeadingTrivia();

        newModifier = newModifier.WithLeadingTrivia(leadingTrivia);

        return typeDeclaration.WithModifiers(
            SyntaxFactory.TokenList(
                typeDeclaration.Modifiers
                    .Where(m => m.Kind() is not SyntaxKind.PublicKeyword and not SyntaxKind.InternalKeyword)
                    .Prepend(newModifier)));
    }
}
